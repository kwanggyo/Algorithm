# 문제에서 25가 나오면 혹시 DP이고 배열? -> 2^25를 생각
# 만약에 30이 나오면 2^30은 x 이런 생각 xxxxx
# N이 30이하이면 재귀 냄새 + 가지치기, DP 요소가 있으면 DP 활용
# 10x25 -> 5x12 : 최대 60개 놓을 수 있음
# 50tc 3초 -> 1tc 당 6천만번
# 재귀 설계를 할 때
# 1. 트리형태를 그려서 branch, level 수 명확하게
# 2. 가지치기 : used, visited, ... 여기서는 1. used, 2. map 확인(놓은 수 있는 곳)

# backtracking : 재귀
    # 1. 트리형태
    # 2. 가지치기
    # 3. DP 요소 발굴
# 완전탐색 : for, 재귀
    # EASY 문제 : 재귀로 구현하고 가지치기 단순하게 하나 넣기
    # 난이도가 있으면 : 완탐 + 다른 알고리즘
    # MID : 가지치기 조건 싹 다 넣기
    # HARD : 가지치기 싹 다 넣고 DP
# DFS : 그래프

# -------------------------------------------- #
# 나중에 10 x 25 로 돌려서 계산하는게 빠름 -> 겹칠 확률을 높음
# ex) 21002111121 or 212100000211121112121111 앞에 있는 것이 겹칠 확률이 높음
# 다른 언어에서 배열을 만들때 10% 정도 넉넉하게 -> 휴먼에러를 줄이기 위함

# DP
# 1. Top-Down
    # 피보나치 getFibo(n)
    #
# 2. Down-up

# 한 줄에 함수를 많이 적지 않기 ! (PS에서) 실무에서는 괜찮
